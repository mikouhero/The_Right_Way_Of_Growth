



# MVCC（多版本并发控制）

`MVCC 使得 InnoDB 更好的实现事务隔离级别中的 REPEATABLE READ`

版本链：对于该记录的每次更新，都会将值放在一条undo日志中，算是该记录的一个旧版本，随着更新次数的增多，所有版本都会被roll_pointer属性连接成一个链表，即为版本链。   

+ 它使得 InnoDB 不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销，就可以实现非锁定读，从而大大提高数据库系统的并发性能。
+ 实现：InnoDB 实现 MVCC 的方法是它为每一行存储三个额外的隐藏字段
+ 1.DB_TRX_ID：一个 6byte 的标识，每处理一个事务，其值自动 + 1 ，可以通过语句 “show engine innodb status” 来查找
+ 2.DB_ROLL_PTR: 大小是 7byte, 指向写到 rollback segment（回滚段）的一条 undo log 记录
+ 3.DB_ROW_ID: 大小是 6byte, 该值随新行插入单调增加。
+ SELECT：返回的行数据需要满足的条件： 1、数据行的创建版本号必须小于等于事务的版本 2、行的删除版本号 (行中的特殊位被设置为将其标记为已删除) 一定是未定义的或者大于当前事务的版本号，确定了当前事务开始之前行没有被删除。
+ INSERT：InnoDB 为每个新增行记录当前系统版本号作为创建版本号。
+ DELETE：InnoDB 为每个删除行的记录当前系统版本号作为行的删除版本号。
+ UPDATE：InnoDB 复制了一条数据。这条数据的版本号使用了系统版本号。它也把系统版本号作为老数据的删除号。
+ 说明：这里的读是不加锁的 select 等，MVCC 实现可重复读使用的是读取 undo 中的已经提交的数据，是非阻塞的。insert 操作时” 创建时间”=DB_ROW_ID，这时” 删除时间” 是未定义的；update 时，复制新增行的” 创建时间”=DB_ROW_ID，删除时间未定义，旧数据行” 创建时间” 不变，删除时间 = 该事务的 DB_ROW_ID； delete 操作，相应数据行的” 创建时间” 不变，删除时间 = 该事务的 DB_ROW_ID；

 - readview：
    + 未提交读：因为可以读到未提交事务修改的记录，所以可以直接读取记录的最新版本就行
    + 已提交读：每次读取之前都生成一个readview
    + 可重复读：只有在第一次读取的时候才生成readview
    + 可串行化：InnoDB涉及了加锁的方式来访问记录
